
		  oldsce v1.10 SC61860 CPU エミュレータ

  以前 X68000/WS で動くポケコン用CPUの SC62015 エミュレータとして sce 、クロ
スアセンブラとして scasm を公開させていただきましたが、今度は旧タイプの CPU
である SC61860 エミュレータを作成しました。
  この SC61860 はちょっと前までの SHARP ポケコンや、電子手帳 PA-7000/8000 シ
リーズで使われています。これは純粋な CPU のみのエミュレータで、ハードウエア
やシステムコールのエミュレートはしていません。よってポケコンのプログラムがそ
のままで即動く、というわけではありませんが、当時の懐かしいプログラミングがで
きますし、拡張もそう難しいものではないでしょう。
  開発は X68000 上で行いましたが Makefile の指定部分の修正だけで UNIX ワーク
ステーション上でもそのまま動きます。(NEWS-OS4で確認) 単純な動作比較はできま
せんが、PC-1245/50/51/55 等よりは速いと思います。



●使い方

  付属の sysinit というファイルをカレントディレクトリにおき、oldsce.x を実行
します。引数で実行するプログラムファイルを与えることができます。


  プログラムファイルのフォーマットは２種類あります。１つはマシン語命令をベタ
で書いたバイナリファイルで、例えばクロスアセンブラで出力したオブジェクトが指
定できるでしょう(scasm.x + macro 等)。プログラムは 2000 番地から始まるように
さえ書いておけば、

	oldsce プログラムファイル

のようにして直接実行できます。


  もう１つは後述するHEXテキスト形式で、これはマシン語をテキストファイルとして
記述します。(マクロ定義によって簡易アセンブラにもなります) これも 2000 番地か
ら始まるよう書いておいて、

	oldsce -h HEXテキストプログラムファイル

のようにして実行します。

  HEXテキスト形式のサンプルは、全部この hexテキストで書いてあります。例えば付
属の asmsmpl というプログラムは、

	oldsce -h asmsmpl

のようにして実行することができます。



●サンプルプログラム

  monitor	マシン語モニタ例です。任意アドレスのダンプ、メモリエディット、
		サブルーチン呼び出し等ができます。? で使用できるコマンドのヘ
		ルプが出ます。

  asmsmpl	ニモニック定義した asm.hed を利用して、簡易アセンブラとして記
		述した例です。実行させてもたいした事はありませんが、中の記述
		を参考にして下さい。

  saikoro	これも asm.hed による簡易アセンブラのサンプルです。

  cmd		コマンドラインもどきです。最初に oldsce -h cmd として実行する
		と、1800～以降に常駐(?)して、以後 cmd> というプロンプトが出ま
		す。コマンド名を打つとそれを hexテキストファイルであると見な
		してロードし、実行します。コマンドは 2000 から実行できるよう
		になっていなければなりません。コマンド引数は X で渡されます。
		この上から monitor や asmsmpl、type 等の他のサンプルプログラ
		ムが実行できます。内部コマンドは以下のとおり。

			quit	終了します
			dir	ファイルリストを表示します

  type		cmd からの呼び出される外部コマンドです。type filename として
		指定ファイルの内容を画面に表示します。ただしあまり大きなファ
		イルは与えないで下さい。(最大50Kbyteほど)

  ls		cmd 組み込みの dir と違い、ファイル名を横に並べて表示するリス
		トコマンドです。



●コマンドオプションの詳細

	oldsce [<option>] [<corefile>]

  起動時に、カレントにある sysinit というHEXテキスト形式のファイルを読み込も
うとします。この sysinit はシステムの初期化ルーチンの定義を行います。付属の
 sysinit の場合は、内ROM 領域にロードされ、J, R のレジスタを初期化した後ユー
ザーエリア最初の 2000 番地を CALL します。CALL から戻ってきたらプログラムを
終了させます。また、内ROM のサービスルーチンの登録も行っています。

  sysinit がない場合は、PC の初期値を 0 にしてプログラム実行を開始します。よっ
て、プログラムが無いままいきなりデタラメなコードを実行してしまいます。

  オプションは以下の通りです。

	-e<addr>	プログラムの実行アドレス、つまり PC の初期値を与えま
			す。デフォルトは 0000 です。

	-l<addr>	corefile をロードするアドレスを指定します。デフォルト
			は 2000 です。

	-h <hexfile>	指定した hex テキストファイルを読み込みます。-h とファ
			イル名との間にはスペースがあってもなくても構いません。

	-t<level>	トレースモードを指定します。
			  -t1	アドレスとポインタレジスタのみ報告、1fff以前
				のアドレス(内ROM領域)のコードは表示を行わない
			  -t3	-t1 に加えて、内RAMのダンプ表示も行う
			  -t5	1fff以前のコードもトレース表示する
			  -t7	-t3 + -t5、すべてのアドレスにおいてトレース表
				示と内RAMダンプを行う

 <corefile> は、メモリイメージをそのままファイルに落としたバイナリ形式です。
例えばクロスアセンブラ等の出力が指定できます。

  RAM領域は何の初期化も行わないため、sysinit 等の HEXテキストや corefile 等で
最初になんらかのメモリイメージを与えてやらなければなりません。



●内部 ROM とユーザーエリア

  SC61860 は 0000～1fff が 8Kbyte の CPU 内部の ROM に相当するため、ユーザー
用の RAM 領域は 2000 番地から始まります。CPU 内部と外部とではアドレス空間が若
干異なっていて、

	CPU内部ROM	アクセス可能ポインタ	PC
	ユーザーRAM	アクセス可能ポインタ	DP, PC
	VIDEO-RAM	アクセス可能ポインタ	DP

という区別があります。ただしこのエミュレータでは 64Kbyte のすべての空間が RAM
に割り当てられているものとし、ポインタの性質に区別なくすべて読み書きができま
す。



●HEXテキストファイル

  クロスアセンブラ等がなくても極簡単にプログラムコードをロードできるように、
16進数でコードを書いたテキストファイルを読み込ませることができるようになって
います。ロード時にシンボル処理が可能です。記述可能なコマンドは以下の通りです。

	.addr:アドレス		コード展開アドレスを設定します。(ロケーショ
				ンカウンタの設定)アドレスは必ず16進数４桁で
				す。

	.exec:アドレス		PC の初期値を設定します。通常はこの指定は行
				う必要はありません。

	.equ:アドレス		直前のラベルにアドレスを代入します。シンボル
				の定義に使います。

	.include:ファイル	指定ファイルをインクルードして評価します。正
				当なラベルの評価を行うために、このインクルー
				ドファイル自身も２パスします。このコマンドの
				評価は１パス目でのみ行われます。

	.qinclude:ファイル	指定ファイルをインクルードします。ただし１パ
				スしかしません。シンボル定義のみ行っているファ
				イルなど、２パスする必要のないファイルを高速
				読み込みすることができます。このコマンドの評
				価は、１パス目でのみ行われます。

				<例>	.qinclude:syscall.hed

	HEX文字列		16進数文字列はそのままメモリ上に展開されます。
				2桁ごと判定されます。

	"文字列～"		文字列をバイトデータ列としてメモリ上に展開し
	'文字列～'		ます。"～" と '～' の区別はありません。" を含
				む文字列では '～' を、' を含む時は "～" を、
				というように使い分けて下さい。

	:ラベル名		ラベルを定義します。つまり、ラベルシンボルに
				ロケーションカウンタの値を代入します。

	@ラベル名		現在位置とラベルアドレスとの差分１バイトをメ
				モリ上に展開します。展開値は JR 命令のジャン
				プオペランドに相当します。

	Hラベル名		ラベルの上位１バイトのみを展開します。

	Lラベル名		ラベルの下位１バイトのみを展開します。!ラベル
	!ラベル名		と書いても同じです。

	*ラベル名		ラベルの内容２バイトを展開します。H,L の順で
				す。

	_ラベル名		ラベル内容に e000 を加えた２バイトを展開しま
				す。つまりこれはCAL命令になります。内ROM 領域
				である 0000～1fff に展開したルーチンは、
				「_ラベル」と記述するだけで呼び出しできるこ
				とになります。いわゆるシステムコール呼び出し
				に便利でしょう。

	;コメント		; または # で始まる行は無視します。
	#コメント

  ラベル名は、15文字以内ならコントロールコード、スペース、カンマを除くどんな
文字を使っても構いません。大文字小文字は区別します。

　このラベル定義を利用して簡易アセンブラを作ることができます。付属の asm.hed
が、そのアセンブラ定義を行っています。ニモニックは !命令 として記述します。

  <例>	  !LII 00

  定数はそのまま16進数で書くか、"文字" または '文字' という表現ができます。

  <例>	  !LIA 'A'

  JR 命令や LOOP 等、相対ジャンプ命令では、飛び先アドレスを @ラベル として記
述します。

  <例>	  !JRZP @EXIT

	:EXIT

  JP 命令や LIDP、CALL 等、絶対アドレスを記述する命令では、アドレスを *ラベル
と書きます。

  <例>	  !CALL *SUB1

  内部ROMのサービスコールは、_ルーチン名 という形で呼び出せます。

  <例>	  !LIA 'A'
  	  _putc

  などなど、asm.hed の使用例として asmsmpl ファイルを参照して下さい。

注意！２重定義、未定義ラベルなどエラーチェックはありません。



●疑似 I/O

  文字の入出力のために PORT-A を割り当ててあります。INA によって A レジスタ
にキー入力が読み込まれ、OUTA によって1文字を画面出力することができます。

  PORT-B は、OS との簡単なリンクに使用しています。出力する値は、1byte目がファ
ンクションコード、2byte目が引数バイト長、以後が可変長の引数です。ファンクショ
ンコードは以下のようになっています。

  00	PORT-B の初期化です。引数はないので、データ長00、つまり常に 00 00 の
	2byteになります。最後に INB で終了ステータスが返ります。

  01	coreファイルをロードします。引数は先頭2byteがロードアドレス、以後ファ
	イル名です。ファイル名は終端の NUL を含みます。最後に INB で終了ステー
	タスが返ります。

  02	hexテキストファイルをロードします。引数はファイル名のみです。最後に
	INB で終了ステータスが返ります。

  03	coreファイルをセーブします。引数は、先頭2byteが先頭アドレス、次の2byte
	がセーブ長、そのあとファイル名です。最後に INB で終了ステータスが返り
	ます。

  04	hex テキストファイルに、16進数ダンプでセーブします。引数は 03 と同じ
	です。最後に INB で終了ステータスが返ります。

  05	ディレクトリのファイル名リストを得ます。引数はなく、このコード出力後
	に INB によってファイル名が送られてきます。ファイル名の区切りは改行
	0a で、00 が終端です。

  06	ファイルサイズを求めます。引数は 02 同様ファイル名のみです。このコー
	ド出力後に INB によって 2byte のサイズが転送されます。

  07	INB に乱数値1byteを返します。引数はありません。


  終了ステータスは、01 なら正常終了、それ以外ならエラーです。

  また、コントロールポートに 0x08 を出力すると、このエミュレータが終了するよ
うになっています。本来このコントロールビットは電源オフに相当します。

  I/O ポートはこれ以外の機能をいっさい持っていません。よって、もし TEST 等に
よってコントロールポートのタイマを見ているようなプログラムがあれば、そのまま
永久ループしてしまうでしょう。



●未対応命令

  一部の命令をサポートしていません。対応していないのは、BCD 演算関連 ADN, ADW
SBN, SBW, SRW, SLW です。これらは実行しても何も起こりません。

  なお CPU 自体の未定義命令を実行しようとした場合はエラーを表示して停止します。



●フラグおよび破壊レジスタ

  命令ごとに破壊されるレジスタやフラグ設定は、私の知っている限りでできるだけ
対応を行いました。例えば

	43	INCB	; B++
	21	LDQ	; A=Q

という組み合わせで、A に 03 が入る、等の小技を使ったものや、D4 ANID、JR命令で
スタック上に残る痕跡なども再現してあります。35 命令を使った PC レジスタの読み
出しも可能でしょう。



●動作上の違い

  エミュレーション上の若干の命令動作の違いがあります。例えば、P,Q,R レジスタ
は本来 7bit なので、P で K レジスタを指定するのに

	12 08	LDP	; P=08
	12 88	LDP	; P=88

のどちらを実行しても同じですし、7F の時に INCP をすると 00 になります。このエ
ミュレータでも通常は問題ありませんが、MVW 等の内RAMを連続転送したりする命令で
 P の値をインクリメントする時は P の値が 00 に戻りません。極めて細かい差違な
ので通常はまず問題は起こらないと思います。

  また内部RAMは本来 00～5f の 96byte ですが、ポインタレジスタ(P等)が 7bit あ
ることから、このエミュレータでは誤動作を防ぐために 128byte 分アクセスが可能
になってしまっています。つまり、60～7f は隠しレジスタ(?)として読み書きできま
す。

  NOP と NOPT 、WAIT は動作時間に差はなく全く同じです。(何もしません)



●トレースレベル

  -t オプションに与える数値の各ビットは以下の意味を持ちます。(与える数値は16
進数)

	bit0:	-t の指定フラグ -t をつけると必ず1になる
	bit1:	内RAMダンプ出力フラグ
	bit2:	内ROMトレースフラグ
	bit3:	hexテキストファイル読み込み時のラベル内容出力

注意: hexテキストファイルのラベル値出力を行う場合は、-t スイッチを -h より先
      に書かないと有効になりません。

   <例>  oldsce -t8 -h asmsmpl

      通常 sysinit のラベル値は出力されないようになってますが、特に表示させた
      い場合は oldsce -t8 -h sysinit のようにコマンドラインから指定します。



●マクロ命令

  付属の sysinit では、PC-1245/50/51/55 の有名なマクロ命令をほんのわずかだけ
定義してあります。

 F1E9	CAL 11e9	X=BA
 F1EE	CAL 11ee	Y=BA
 F1F1	CAL 11f1	X=BA-1
 F1F5	CAL 11f5	Y=BA-1

  また、いくつかのオリジナルルーチンとして以下のものを用意してあります。付属
の定義ファイル syscall.hed を include することで、以下のルーチンの呼び出しが
できます。破壊するレジスタがあるので注意して下さい。

_system_start	再スタートします(戻ってきません)
_getc		A=１文字キー入力したコード([CR]が必要)
_gets		改行までのキー入力1行をY+1に読み込む
_putc		A の１文字を表示する
_putcr		改行(0a)出力
_print		00 で終わる X+1 から始まる文字列を表示する
_prtmsg		この CAL 命令以後 00 までの文字列を出力する
_puthex		A レジスタの値16進数出力
_dump		X+1 から16バイトを dump 出力する
_bload		X+1 に loadadr,loadfilename を設定して呼び出し、fileのロード
_hload		X+1 の名前のhexテキストfileをロードします(戻り値A=1なら成功)
_bsave		X+1 に saveadr,len,filename を設定して呼び出し、fileセーブ
_hsave		X+1 に saveadr,len,filename を設定して呼び出し、hexfileセーブ
_files		ファイルリストの表示
_fsize		X+1 のファイル名のファイルサイズの獲得 (戻り値BA)
_rand		A=乱数値
_mul_b		掛け算 A*=B
_div_b		割り算 A/=B,B=A%B
_atoh		A の値を Y+1 から文字列に変換し格納します
_strlen		X+1からの文字列の文字数+1を返す
_strcmp		X+1,Y+1の文字列を比較する
_lix		疑似LIX命令 この CAL 以後の 2byte (-1)を X に代入する
_liy		疑似LIY命令 この CAL 以後の 2byte (-1)を Y に代入する



●ソースリストについて

  ソースリストを X68000 で再コンパイルするには、gcc と jgawk が必要です。ラ
イブラリは libc でも大丈夫だと思いますが確認はしていません。

  UNIX ワークステーションでコンパイルする場合は、ソース全部を転送し Makefile
を書き換えます。最初の「-- UNIX」以下４行のコメントを外し、「-- Human68k」以
下５行をコメントにして下さい。CFLAGS は、それぞれのマシンに合せて
 -DBIGENDIAN か -DLITTLEENDIAN を選択して下さい。DEC 系、インテル系以外のマ
シンはほとんど BIGENDIAN です。もしスイッチが間違っている時は、起動時にメッ
セージを表示します。動作確認は、NEWS-OS4.2C でのみ行っています。

 ---< NEWS-OSでの指定例 >--- Makefile の最初の部分だけです
#### -- UNIX
CC	= cc
CFLAGS	= -O -DBIGENDIAN -DUNIX
#CFLAGS	= -O -DLITTLEENDIAN -DUNIX
PROG	= oldsce
AWK	= awk
#### -- Human68k
#CC	= gcc
#CFLAGS	= -O -DBIGENDIAN -DHUMAN -fstrength-reduce -fomit-frame-pointer \
#		-finline-functions -fforce-addr -fforce-mem -fcombine-regs
#PROG	= oldsce.x
#AWK	= jgawk
####
 ---------------------------

  ラベルの最大定義個数は、hexfile.c の先頭、「MAXLAB」というシンボルで変更で
きます。初期値は 1024 です。



●簡単にプログラムを組んでみよう

  エミュレータは仮想コンピュータです。この上で組んだプログラムなら暴走しても
何の心配もありません。マシン語経験のない方も、直接メモリ操作にかかわるマシン
語の世界をちょっと体験してみましょう。

  というわけで、hexテキストファイル形式で、簡単にプログラムを組む方法を説明
します。まずファイルの先頭に次の３行を必ず書き込んでおいて下さい。初期化を行
います。

	.qinclude:syscall.hed
	.qinclude:asm.hed
	.addr:2000

  最初は簡単に、文字列の表示でも行ってみましょう。syscall の _prtmsg を使い、

	_prtmsg	"Hello World!" 0a 00

とでも書いておきます。ここでの 0a は改行で、Ｃ言語でいえば '\n' に相当します。
最後の 00 は、文字列の終わりを示す '\0' です。


  プログラムの最後には、システムに戻るための

	!RET

が必要です。全部で５行しかありませんが、これでおしまいです。適当なファイル名
でセーブします。もし hello という名前でセーブしたなら、

	oldsce -h hello

と実行して下さい。

ldsce - sc61860 emurator v1.10 1994 by H.Ogasawara (COR.)
load 'hello'
SystemInit v0.02 1994 by COR.
Hello World!
PowerOff..exit

という表示で終われば成功です。もし「SystemInit ...」とで続けて止まらなくなっ
た時はシンボル名が間違っています。これは未定義シンボルを CALL して、0 番地に
飛んでリセットがかかっているということなので、"_prtmsg" のスペルを確認して下
さい。

  次に、トレース実行をして見ましょう。まず、トレースレベル 1 です。先程のプ
ログラムを次のようにして実行します。

	oldsce -h hello -t1

この -t1 という指定がトレース実行を意味します。

oldsce - sc61860 emurator v1.10 1994 by H.Ogasawara (COR.)
load 'hello'
SystemInit v0.02 1994 by COR.
2000: e0 50     (2) p:5c q:06 r:5a dp:0026 f:01 CAL
Hello World!
2010: 37        (1) p:5a q:06 r:5a dp:2010 f:01 RET
PowerOff..exit

  このような結果が出たことと思います。これは、命令１つ１つを表示しながら実行
を行っています。

  SystemInit の次の行を見て下さい。まずプログラムは 2000 番地からスタートし
たことがわかります。ここに書いてある命令は、e0 50 の２バイトで、ニモニックに
すると CAL 0050 であるということを意味しています。これは先程の _prtmsg シン
ボルが、命令に展開されているわけです。

  ここで本当は 0050 番地に飛ぶのですが、このトレースレベル1 ではシステムコー
ル内のトレース表示は省略してくれます。この 0050 のルーチンで Hello World! と
いう文字列を表示したあと 2010 番地を実行しています。番地が飛んでいるのは、間
に「Hello World!」という文字列があるからです。2010 番地では 37 という１バイ
トの命令、これは RET ですので、ここでシステムに戻って終了しています。

  これだけでは、命令とポインタの値しか見れないのでレジスタの動きがわかりませ
ん。そこで、今度はトレースレベル 3 で実行してみます。

	oldsce -h hello -t3

今度はさっきよりずっと量が多く次のように表示されます。

oldsce - sc61860 emurator v1.10 1994 by H.Ogasawara (COR.)
load 'a'
SystemInit v0.02 1994 by COR.
2000: e0 50     (2) p:5c q:06 r:5a dp:0026 f:01 CAL
00 01 5a 00 26 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 4e 46 57 00 29 00 0a 00 00
Hello World!
2010: 37        (1) p:5a q:06 r:5a dp:2010 f:01 RET
00 01 58 00 10 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 4e 46 57 00 10 20 29 00 0a 00 00
PowerOff..exit

  このいっぱい数字が並んでいるのがレジスタの値です。SC61860 はレジスタが 96
個もあるので、このように表示されるのです。この CPU では、スタックもレジスタ
上に取られます。トレースの最初の行にある r:5a というのがスタックポインタです。
 R レジスタが 5a 番目のレジスタを指しています。ここがスタックトップで、右か
ら左へと push が行われます。他にもいろいろ役割を持ったレジスタはありますが、
 3番目のレジスタがアキュムレータ A というのは覚えておくといいでしょう。

  このプログラムでは特にレジスタ操作はありませんが、レジスタ列のの最後のス
タックのあたりを見ると、2000 番地の時と 2010 番地の時では、4e 46 57 00 とい
う並びが１つずれているように見えます。そして 2010 番地のレジスタ列でその隣に
ある 10 20 というのが、逆順になってますが CAL 命令の戻り番地 2010 を意味して
います。スタックポインタ r の値は変化していませんが、このようにスタック上に
はちゃんと、CAL 命令によるシステムコールが行われた証拠が残っているわけです。



●命令表

00n	LII n		I=n
01n	LIJ n		J=n
02n	LIA n		A=n
03n	LIB n		B=n
04	IX		DP=++X
05	DX		DP=--X
06	IY		DP=++Y
07	DY		DP=--Y
08	MVW		[(P++)=(Q++)]I
09	EXW		[(P++)<=>(Q++)]I
0a	MVB		[(P++)=(Q++)]J
0b	EXB		[(P++)<=>(Q++)]J
0c	ADN		[(P++)+=A]I
0d	SBN		[(P++)-=A]I
0e	ADW		[(P++)+=(Q++)]I
0f	SBW		[(P++)-=(Q++)]I
10nm	LIDP nm		DP=nm
11n	LIDL n		DPL=n
12n	LIP n		P=n
13n	LIQ n		Q=n
14	ADB		(P)2+=BA
15	SBB		(P)2-=BA
18	MVWD		[(P++)=(DP++)]I
19	EXWD		[(P++)<=>(DP++)]I
1a	MVBD		[(P++)=(DP++)]J
1b	EXBD		[(P++)<=>(DP++)]J
1c	SRW		[(P)..(P+I)]>>4
1d	SLW		[(P)..(P+I)]<<4
1e	FILM		[(P)..(P+I)]=A
1f	FILD		[(DP)..(DP+I)]=A
20	LDP		A=P
21	LDQ		A=Q
22	LDR		A=R
23	CLRA		A=00
24	IXL		A=(DP=++X)
25	DXL		A=(DP=--X)
26	IYS		(DP=++Y)=A
27	DYS		(DP=--Y)=A
28n	JRNZP n		!Z ? PC+=n
29n	JRNZM n		!Z ? PC-=n
2an	JRNCP n		!C ? PC+=n
2bn	JRNCM n		!C ? PC-=n
2cn	JRP n		PC+=n
2dn	JRM n		PC-=n
2fn	LOOP n		(R)--, !C ? PC-=n : R++
30	STP		P=A
31	STQ		Q=A
32	STR		R=A
34	PUSH		(--R)=A
35	DATA		(P)I=(BA)
37	RET		PC=(R++)2
38n	JRZP n		Z ? PC+=n
39n	JRZM n		Z ? PC-=n
3an	JRCP n		C ? PC+=n
3bn	JRCM n		C ? PC-=n
40	INCI		I++
41	DECI		I--
42	INCA		A++
43	DECA		A--
44	ADM		(P)+=A
45	SBM		(P)-=A
46	ANMA		(P)&=A
47	ORMA		(P)|=A
48	INCK		K++
49	DECK		K--
4a	INCM		M++
4b	DECM		M--
4c	INA		A=PORTA
4d	NOP		NOP
4en	WAIT n		WAIT n
50	INCP		P++
51	DECP		P--
52	STD		(DP)=A
53	MVDM		(DP)=(P)
54	READM		(P)=(PC)
55	MVDM		(P)=(DP)
56	READ		A=(PC)
57	LDD		A=(DP)
58	SWP		AL<=>AH
59	LDM		A=(P)
5a	SL		A<<=1
5b	POP		A=(R++)
5d	OUTA		PORTA=(5c)
5f	OUTF		PORTFO=(5e)
60n	ANIM n		(P)&=n
61n	ORIM n		(P)|=n
62n	TSIM n		(P)&n
63n	CPIM n		(P)-n
64n	ANIA n		A&=n
65n	ORIA n		A|=n
66n	TSIA n		A&n
67n	CPIA n		A-n
69n...	CASE n...	table jump
6bn	TEST n		TEST&n
70n	ADIM n		(P)+=n
71n	SBIM n		(P)-=n
74n	ADIA n		A+=n
75n	SBIA n		A-=n
78nm	CALL nm		(--R)2=PC,PC=nm
79nm	JP nm		PC=nm
7anml	SET nml		S=n,(--R)2=ml
7cnm	JPNZ nm		!Z ? PC=nm
7dnm	JPNC nm		!C ? PC=nm
7enm	JPZ nm		Z ? PC=nm
7fnm	JPC nm		C ? PC=nm
80	LP 00		P=00
81	LP 01		P=01
 :	:		:
bf	LP 3f		P=3f
c0	INCJ		J++
c1	DECJ		J--
c2	INCB		B++
c3	DECB		B--
c4	ADCM		(P)+=A+C
c5	SBCM		(P)-=A+C
c6	TSCM		(P)&A
c7	CPCM		(P)-A
c8	INCL		L++
c9	DECL		L--
ca	INCN		N++
cb	DECN		N--
cc	INB		A=PORTB
ce	NOPT		NOP 3
d0	SC		C=1,Z=1
d1	RC		C=0,Z=1
d2	SR		A>>=1
d4n	ANID n		(DP)&=n
d5n	ORID n		(DP)|=n
d6n	TSID n		(DP)&n
d8	REAVE		(R)=00
da	EXAB		A<=>B
db	EXAM		A<=>(P)
dd	OUTB		PORTB=(5d)
df	OUTC		PORTC=(5f)
e0n	CAL nm		(--R)=PC,PC=00n
e1n	CAL nm		(--R)=PC,PC=01n
 :	:		:
ffn	CAL nm		(--R)=PC,PC=1fn


  これらの命令定義とその実行ルーチン名は、すべて opexec.c 内で定義しています。



●レジスタ表

・内RAMレジスタ

内RAMadr   レジスタ名
   00		I
   01		J
   02		A
   03		B
   04		XL
   05		XH
   06		YL
   07		YH
   08		K
   09		L
   0a		M
   0b		N


・ポインタ、フラグ

  P	内RAMポインタ
  Q	内RAMポインタ
  R	内RAMポインタ(スタック用)
  DP	データポインタ(外部メモリポインタ)
  PC	プログラムカウンタ
  Z	ゼロフラグ
  C	キャリーフラグ

  これらのレジスタ定義は、すべて reg.h 内で行っています。




●最後に

  SC62015 のエミュレータに比べたら命令も動作も単純なので、このプログラムは極
めて簡単です。
  SC62015 の時とは異なり、特に int = 32bit でなくても構わないので、DOS 系の
マシンでも比較的動かしやすいのではないかと思います。
  開発は、X68000XVI Human68k v2.02 + Ko-Window 上で行いました。付属の実行ファ
イルは XCv1 のライブラリを使い gcc でコンパイルをしています。


小笠原博之
  SPS-NET: SPS0783 COR.
DenDenNET: DEN0006 COR.




